[toc]
# 1. 压缩字符展开

## 题目描述

描述：

现在我们约定一种新的字符串“压缩”形式，它具有以下规则：

- 原始串和压缩后的串均不含中括号 [ 和 ] 。
- 原始字符串由 `[a-z]`,`[A-Z]`,`{`,`}`,`[0-9]` 这些字符(每个中括号内是 ASCII 码连续的字符集合)组成；
- 压缩后的字符串中的字符和原始字符串中字符组成相同；
- 压缩字符 `*` 对应原始字符 `*`，其中 `*` 在 `[a-z]`, `[A-Z]`, `[0-9]` 中；
- 特别的，规定 `{{}` 对应原始字符 `{`、`{}}` 对应原始字符 `}`,不会出现 `{{{}`, `{}}}`, `{{}}` 等形式。
- 压缩字符 `*{_}` 对应原始字符 `**...`（即 `_` 次 `*`），其中 `*` 是原始字符中的任何一个， `_` 是一个小于 30 的正整数；
- 不会出现类似 `a{4}{4}` 的形式。

现在给出压缩字符串，请你输出它对应的原始字符串。

## 输入格式

一个符合给定压缩格式的压缩后字符串，假定压缩是正确的。

## 输出格式

对应的原始字符串。

## 样例 #1

### 样例输入 #1

```
abcd
```

### 样例输出 #1

```
abcd
```

## 样例 #2

### 样例输入 #2

```
ab{2}cd
```

### 样例输出 #2

```
abbcd
```

## 样例 #3

### 样例输入 #3

```
ab{}}cd
```

### 样例输出 #3

```
ab}cd
```

## 样例 #4

### 样例输入 #4

```
ab{{}{3}cd
```

### 样例输出 #4

```
ab{{{cd
```

## 样例 #5

### 样例输入 #5

```
ABCD123
```

### 样例输出 #5

```
ABCD123
```

## 样例 #6

### 样例输入 #6

```
ABCD1{2}23
```

### 样例输出 #6

```
ABCD1123
```

## 提示

压缩后的字符串长度小于100。
# 2. 除法

## 题目描述

给出两个二进制表示下的**正整数** n1 和 n2，计算他们相除后的相关内容。

## 输入格式

输入包含两行：

- 第一行是二进制表示下的被除数。
- 第二行是二进制表示下的除数。

简化起见，这里二进制数字都以 `1` 开始，并且都是正整数，被除数的长度大于等于除数。

## 输出格式

结果由两行组成：

- 第一行是 商。
- 第二行是 被除数余数。

其中，余数被 `0` 填充为和除数相同长度。

注意，**第二行由两个数字组成：被除数、余数**。被除数和余数中间没有空格。

## 样例 #1

### 样例输入 #1

```
1010
10
```

### 样例输出 #1

```
101
101000
```

## 样例 #2

### 样例输入 #2

```
1010
11
```

### 样例输出 #2

```
11
101001
```

## 样例 #3

### 样例输入 #3

```
1010
1010
```

### 样例输出 #3

```
1
10100000
```

## 提示

以样例1为例：
```txt
被除数    : 10             (0b1010)
除数      :  2             (0b10)
计算除法  : 10  //  2  = 5 (0b101)
计算余数  : 10 - 2 * 5 = 0 (0b00)，这里需要补齐到和除数相同的位数。
```
因此输出为
```
101(除法结果)
1010（被除数）00（余数）
```

在数字中，我们给出以下约定：
- 被除数的长度小于38。
- 除数的长度小于38。

这里有[其他资料](https://www.bing.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%99%A4%E6%B3%95+-site%3Acsdn.net)。

当然，转十进制再转二进制也是可以的。
# 3. 子网判断

## 题目背景

#### IPv4

> IPv4地址可被写作任何表示一个 32 位整数值的形式，但为了方便人类阅读和分析，它通常被写作点分十进制的形式，即四个字节被分开用十进制写出，中间用点分隔。

IPv4 地址是一个 32 位整数值，例如 `11011011110110110111100001001000`。

为了方便阅读，通常被每8位用 `.` 分割开，并转为十进制的形式，以上述地址为例(可以打开看看它是什么？)：
~~~
11011011.11011011.01111000.01001000 (点分二进制)
219.219.120.72 (点分十进制)
~~~

#### 网络划分

将一个 IPv4 地址划分为两部分，网络号和主机号，其中网络号的截止位是人为指定的。

```txt
00001000.00010100.00001111.00000001
-----------------------------------
  net id  |      host id         
```

#### 子网掩码

为了方便表达，引入子网掩码表达一个地址的网络号和主机号信息。子网掩码有以下特点：

- 是一个 32 位整数值的形式；
- 二进制表示下，所有的 0 和所有的 1 必须分别连续；
- 如果有 1，那么 1 必须在开头。
- 同样可以被写做点分十进制的形式。

例如：
- `00000000.00000000.00000000.00000000` 是一个有效的子网掩码。
- `11111111000000001111111100000000` **不是**一个有效的子网掩码，因为 1 不连续。
- `00000000.11111111.00000000.00000000` **不是**一个有效的子网掩码，因为 1 不在开头。
- `255.0.0.0` 是一个有效的子网掩码。

将子网掩码和一个 IPv4 地址做 `与` 运算，即可得到这个地址的网络号，例如：

~~~txt
10101100.00010000.00010001.00011110 (IPv4 地址: 172.16.17.30)
11111111.11111111.11110000.00000000 (子网掩码: 255.255.240.0)
-----------------------------------
10101100.00010000.00010000.00000000 (网络号: 172.16.16.0)
~~~

#### IPv4 地址与子网

如果两个 IPv4 的地址的网络号相同，那么称它们 `处于同一个子网`。

## 题目描述

判断给定的两个 IPv4 地址是否处于同一个子网。

## 输入格式

输入由三行组成：

- 第一行是一个点分十进制表示的 IPv4 地址。
- 第二行是一个点分十进制表示的子网掩码。
- 第三行是另一个点分十进制表示的 IPv4 地址。

## 输出格式

只需要 `False` 或者 `True`（首字母大写）:

- `True` 表示两个地址处于同一个子网。
- `False` 表示两个地址不处于同一个子网。

## 样例 #1

### 样例输入 #1

```
192.168.1.1
255.255.255.0
192.168.1.1
```

### 样例输出 #1

```
True
```

## 样例 #2

### 样例输入 #2

```
192.168.1.1
255.255.255.0
192.168.1.2
```

### 样例输出 #2

```
True
```

## 样例 #3

### 样例输入 #3

```
192.168.1.1
255.255.255.0
192.168.2.1
```

### 样例输出 #3

```
False
```

## 提示

- 可以认为所有的子网掩码都是正确的。
- 可以认为所有的 IPv4 地址都是正确的。

这里有[参考链接](https://www.cisco.com/c/zh_cn/support/docs/ip/routing-information-protocol-rip/13788-3.html)，也可以自行在互联网上查询相关资料。

使用 C 语言完成，不可以使用网络编程的相关库，例如 `inet.h` 等。
# 4. 地址缩写

## 题目背景

为了解决 IPv4 地址不足的问题，人们推出了 IPv6 地址格式。

#### IPv6 地址

IPv6采用128位二进制的地址表示形式，例如: 
```txt
00100000000000010000110110111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
```
。

为了方便阅读，IPv6 地址被分为8组，每组以4位的16进制数字表示，例如：
```
2001:0db8:0000:0000:0000:0000:0000:0001
2001:0db8:02de:0000:0000:0000:0000:0e13
```

#### IPv6 地址的省略

为了进一步简化地址， IPv6 有以下的省略规则:

- 每项数字 **前导的 0** 可以省略，省略后前导数字仍是0可以继续省略，例如下组IPv6是等价的:
  - `2001:0db8:02de:0000:0000:0000:0000:0e13`
  - `2001:db8:2de:0000:0000:0000:0000:e13`
  - `2001:db8:2de:000:000:000:000:e13`
  - `2001:db8:2de:00:00:00:00:e13`
  - `2001:db8:2de:0:0:0:0:e13`
- 可以用双冒号“::”表示一组0或多组连续的0，**但只能出现一次**，例如下组IPv6是等价的:
  - `2001:0db8:0000:0000:0000:0000:1428:57ab`
  - `2001:0db8:0000:0000:0000::1428:57ab`
  - `2001:0db8:0:0:0:0:1428:57ab`
  - `2001:0db8:0::0:1428:57ab`
  - `2001:0db8::1428:57ab`

`2001::25de::cade` 地址是非法的，因为它可以是下列地址的缩写:

```txt
2001:0000:0000:0000:0000:25de:0000:cade
2001:0000:0000:0000:25de:0000:0000:cade
2001:0000:0000:25de:0000:0000:0000:cade
2001:0000:25de:0000:0000:0000:0000:cade
```

## 题目描述

现在给出一个128位二进制的 IPv6 地址，请你将它缩写为最短的形式。

## 输入格式

一个字符串，长度为 128 的 0 1 组合。

## 输出格式

这个字符串对应的 IPv6 地址的最短表示形式。

隐藏用例有多处可以被缩写，但是你需要找出唯一最短的形式，它不是类似于 `2001:0000:0000:25de:25de:0000:0000:cade` 可以缩写为 `2001::25de:25de:0:0:cade` 或者 `2001:0:0:25de:25de::cade` 一种以上最短形式。

换言之，它的最短形式是唯一的。

## 样例 #1

### 样例输入 #1

```
00100000000000010000110110111000000000000000000000000000000000000000000000000000000000000000000000010100001010000101011110101011
```

### 样例输出 #1

```
2001:db8::1428:57ab
```

## 样例 #2

### 样例输入 #2

```
00100000000000010000110110101000000100000000011101000000000100010000000000010000000000000000000000000000000000000000000010000000
```

### 样例输出 #2

```
2001:da8:1007:4011:10::80
```

## 样例 #3

### 样例输入 #3

```
00100000000000010100100001100000010010000110000000000000000000000000000000000000000000000000000000000000000000001000100010001000
```

### 样例输出 #3

```
2001:4860:4860::8888
```

## 样例 #4

### 样例输入 #4

```
00100000000000010000110110101000000100000000011100000000000000000000000000000000000000000000000000000000000000001000100010001000
```

### 样例输出 #4

```
2001:da8:1007::8888
```

## 样例 #5

### 样例输入 #5

```
00100100000000101111000000000000000000000000000100000100000001010000000101100110000000010001000100000000000001010000000010011001
```

### 样例输出 #5

```
2402:f000:1:405:166:111:5:99
```

## 提示

所有的输入都是128位的。

使用 C 语言完成，不可以使用网络编程的相关库，例如 `inet.h` 等。

或许可以考虑递归？

上述地址中：
- 第一个是示例中的地址。
- 第二个是 `test6.nju.edu.cn` 的 IPv6 地址。
- 第三个是谷歌的 IPv6 dns 地址。
- 第四个是[南京大学 IPv6 dns 地址](https://itsc.nju.edu.cn/c0/ad/c21415a442541/pagem.htm)。
- 第五个是[清华大学 iptv](https://iptv.tsinghua.edu.cn) 的地址(校内通过 IPv6 可以直接观看)。