[toc]
# 1. 回文串

## 题目背景

回文串：指正读和反读都一样的字符串，例如 `level`、`noon`。

## 题目描述

请使用指针判断给定的字符串是否为回文串。

## 输入格式

一行字符串。可能包含：

- 大写字母。
- 小写字母。
- 英文表点符号。
- 英文空格。

字符串结束没有换行。（字符串具体结束方法以洛谷实际判断为准。）

## 输出格式

- 如果不是回文串，输出字符串本身；
- 如果是回文串，那么输出它的前半部分。

## 样例 #1

### 样例输入 #1

```
123
```

### 样例输出 #1

```
123
```

## 样例 #2

### 样例输入 #2

```
123321
```

### 样例输出 #2

```
123
```

## 样例 #3

### 样例输入 #3

```
12321
```

### 样例输出 #3

```
123
```

## 提示

字符串长度小于 100。

请尝试处理空格。
# 2. 组合 IP 地址

## 题目背景

IPv4使用32位地址，作为一个二进制串，可以被认为是一个无符号二进制数字。因此可以有“十进制数字”表示形式，例如：

- 0.0.0.1: 1
- 0.0.1.0: 256

## 题目描述

给出一个 `点分十进制` 去掉 `.` 的字符串，请返回所有可能的 IPv4 地址，使用 `,` 分隔不同的地址。

## 输入格式

一行字符串，其中：

1. 字符串确保可以被写为至少一个地址；
2. 字符串中的所有数字都应该被用到（0001 和 00010 是两个不同的输入，结果没有包含关系）；
3. 不可以对字符串中数字重新排序（0002 和 0200 是两个不同的输入）；
4. 地址中不包含前导 0 （00010 只能写为 `0.0.0.10`,而没有 `0.0.01.0`）；

字符串的长度不超过7。

## 输出格式

一行字符串：

1. 是 `点分十进制` 表示的 IPv4 地址；
2. 不包含重复地址；
3. 不同地址之间使用 ',' （英文）分隔；
4. 输出的结果按照`题目背景`中描述的“十进制数字”表示形式下**由小到大**的数字输出。

## 样例 #1

### 样例输入 #1

```
0000
```

### 样例输出 #1

```
0.0.0.0
```

## 样例 #2

### 样例输入 #2

```
00010
```

### 样例输出 #2

```
0.0.0.10
```

## 样例 #3

### 样例输入 #3

```
00110
```

### 样例输出 #3

```
0.0.1.10,0.0.11.0
```

## 提示

示例3中，`1*256+10` < `11*265+0`，因此是如图所示的顺序。

递归的时候，注意递归的`剪枝`(回溯)。
# 3. 正则表达式

## 题目背景

可能之前同学们总被题目中的输入描述绕的头晕，这里向同学们介绍一个有用的字符串描述方式：[正则表达式（Regular Expression）](https://www.bing.com/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)。

## 题目描述

请判断给定字符串和给定的正则表达式是否匹配，匹配采用“贪婪模式”，即当出现次数匹配时，一次尽可能多的匹配字符。

## 输入格式

输入由两行组成，第一行是待匹配字符串，第二行是一个正则表达式，两行字符串长度均小于30。

其中，正则表达式的内容由以下部分组成：

1. 直接字符，这里约定，字符的范围为 `a-z` 和 `0-9` ，这里的字符不需要转义，代表字符本身。
2. 特殊字符：
	- `.`: 匹配任何字符。
   - `*`: 匹配前一个字符的零次到多次。
   - `\`: 转义特殊字符，`\.` 只匹配 `.`， `\*` 只匹配 `*`，`\\` 只匹配 `\`。

待匹配字符串也不会出现上述符号外的其他符号。

## 输出格式

匹配输出 `1`，不匹配输出 `0`。

## 样例 #1

### 样例输入 #1

```
aa
a
```

### 样例输出 #1

```
0
```

## 样例 #2

### 样例输入 #2

```
aa
a*
```

### 样例输出 #2

```
1
```

## 样例 #3

### 样例输入 #3

```
aa
c*aa
```

### 样例输出 #3

```
1
```

## 样例 #4

### 样例输入 #4

```
aac
.*c
```

### 样例输出 #4

```
1
```

## 样例 #5

### 样例输入 #5

```
aacd
.*c
```

### 样例输出 #5

```
0
```

## 样例 #6

### 样例输入 #6

```
aacdc
.*c
```

### 样例输出 #6

```
1
```

## 提示

注意，这次不可使用包括 `regex.h` 在内的正则表达式相关库，也不可以使用任何与正则表达式相关的系统库函数调用。

这里给出一个递归图例：
![递归示例](https://git.nju.edu.cn/dawnkiss/test/-/raw/main/%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B.jpg)
# 附加题3. 正则表达式 V2.0

## 题目背景

对于[正则表达式（Regular Expression）](https://www.bing.com/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)，在附加题中请实现更多的功能。

## 题目描述

请判断:

对给定字符串，使用给定的正则表达式进行搜索，返回的首个匹配串是否是字符串本身。

## 输入格式

输入由两行组成，第一行是待匹配字符串，第二行是一个正则表达式，两行字符串长度均小于50。

其中，正则表达式的内容由以下部分组成：

1. 直接字符，这里约定，字符的范围为 `a-z` 和 `0-9` ，这里的字符不需要转义，代表字符本身。
2. 特殊字符：
	- `.`: 匹配任何字符。
   - `*`: 尽可能多的匹配前一个字符的零次到多次。
   - `+`: 尽可能多的匹配前一个字符的一次到多次。
   - `\`: 转义特殊字符，`\.` 只匹配 `.`， `\*` 只匹配 `*`，`\\` 只匹配 `\`。
   - `?`: 将 `*` 和 `+` 转为非贪婪模式，即尽可能少的匹配前一个字符，这里我们约定 `?` 不会单独出现，也不会出现 `\?` 的情况。

待匹配字符串也不会出现上述符号外的其他符号。

## 输出格式

如果返回的首个字符串是它本身，输出 `1`，否则（没有找到任何串，或者首个字符串不是本身），输出 `0`。

## 样例 #1

### 样例输入 #1

```
abccccbcb
ab.+?cb
```

### 样例输出 #1

```
0
```

## 样例 #2

### 样例输入 #2

```
abccccbcb
ab.+cb
```

### 样例输出 #2

```
1
```

## 样例 #3

### 样例输入 #3

```
aaa\.bca\.abc
.+?a\\\.abc
```

### 样例输出 #3

```
1
```

## 样例 #4

### 样例输入 #4

```
aaa\.abca\.abc
.+?a\\\.abc
```

### 样例输出 #4

```
0
```

## 样例 #5

### 样例输入 #5

```
aaa\.abca\.abc
.+a\\\.abc
```

### 样例输出 #5

```
1
```

## 提示

非贪婪模式的“尽可能少”不等于只匹配一次！

对于**第三个示例**：
- `.+?a` 并没有只匹配到 `aa` 就停止。在匹配过程中，首先保证 _尽可能有一个结果_。
  - `.+?a` 如果在 `aa` 或者 `aaa` 停止导致后续匹配失败，匹配没有结果。
  - `.+?a` 如果在 `aaa\.bca` 停止，后续匹配会成功，因此选用了这个方案。
- 如果有多个可能的匹配结果，非贪婪模式会选择从**首个字符匹配位置开始**（所以它不会只匹配 `ca\.abc`），匹配字符串最少的那种。（示例4）
- 如果有多个可能的匹配结果，贪婪模式选择从**首个字符匹配位置开始**，匹配字符串最多的一种。（示例5）

对于第四个示例:
- `.+?a` 如果在 `aaa` 停止，后续匹配成功，此时搜索结果为 `aaa\.abc`
- `.+?a` 如果在 `aaa\.abca` 停止，后续匹配成功，此时搜索结果为 `aaa\.abca\.abc`
- 非贪婪模式需要返回尽可能少匹配的结果，因此最终匹配是 `aaa\.abc`；对应的，示例5为贪婪模式的情况。

注意，这次不可以使用包括 `regex.h` 在内的正则表达式相关库，也不可以使用任何与正则表达式相关的系统库函数调用。

使用其他语言的同学也不可以使用正则表达式相关的包、库或者函数调用。

作为附加题，此题目主要向同学们介绍正则表达式，有一定的难度（特别是第三个示例），还请同学们量力而为。